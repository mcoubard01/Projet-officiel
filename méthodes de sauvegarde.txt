CE FICHIER EST POUR L'USAGE PERSONNEL DE THOMAS. 
il le supprimera une fois utilisé. 

(ce fichier me permet juste de stocker des bous de code que j'avais écrit auparavant).


/**
     * prend en entrée un tableau String[], dont les cases sont les éléments séparés par ";"
     * (Coin;id;x;y) 
     * crée le coin avec les données fournies
     * @param coinEnString - String[]
     */
    public static void récupérerUnCoin(String[] coinEnString){
        //au 07/05/24 : "#Syntaxe  : \"Coin;id;x;y\""
        int idSouhaité= parseInt(coinEnString[1]);
        int x = parseInt(coinEnString[2]);
        int y = parseInt(coinEnString[3]);
        int idQuiSeraCréé = compteurCoin;
        System.out.println("Création du coin dont l'id est " + idSouhaité);
       
        Coin coinACréer = new Coin(x,y); //crée un coin dont l'identifiant est compteurCoin
        System.out.println("nouveau coin, id devrait être : "+idSouhaité);
        System.out.println("l'id est " + coinACréer.getId());
        if (idQuiSeraCréé != idSouhaité){
            //en créant automatiquement son identifiant, coinACréer a peut-être prit l'identifiant d'un autre coin.
            //Cet autre coin est coinEcrasé, sont identifiant était idQuiSeraCréé
            mapCoin.replace(coinACréer,idSouhaité); //on assigne à coinACréer l'identifiant voulu
            //coinEcrasé est toujours lié vers idQuiSeraCréé dans mapCoin
            
            Coin coinEcrasé = mapIdVersCoin.get(idQuiSeraCréé);
            mapIdVersCoin.put(idQuiSeraCréé,coinEcrasé); //met coinEcrasé sur son id originel
            mapIdVersCoin.put(idSouhaité,coinACréer); // met coinACréer sur le bon id.
            System.out.println("Changements fait. id devait être"+idSouhaité);
            System.out.println("it est maintenant"+mapCoin.get(coinACréer));

        }
    }
    //TODO ; vérifier si ça fonctionne encore avec les nouvelles syntaxes de mur!!
    //TODO : vérifier à nouveau le processus de récpération de données.
    public static void récupérerUnEtage(String [] etageEnString){
        //#Syntaxe : \"Etage;id;hauteur_etage;liste_appartement=[}\""
        int idSouhaité= parseInt(etageEnString[1]);
        int idQuiSeraCréé = compteurEtage;
        int hauteur_etage = parseInt(etageEnString[2]);
        //TODO on assignera les appartements à l'étage quand on crééra les appratements (IDManager.récupérerUnAppartement())
        
        Etage étageACréer = new Etage(hauteur_etage);
        
        //LOG
        System.out.println("nouvel étage, id devrait être : "+idSouhaité);
        System.out.println("l'id est " + étageACréer.getId());
        
        if (idQuiSeraCréé != idSouhaité){
            //en créant automatiquement son identifiant, étageACréer a peut-être prit l'identifiant d'un autre Etage.
            //Cet autre Etage est étageEcrasé, son identifiant était idQuiSeraCréé
            mapEtage.replace(étageACréer,idSouhaité); //on assigne à étageACréer l'identifiant voulu
            //étageEcrasé est toujours lié vers idQuiSeraCréé dans mapEtage
            
            Etage étageEcrasé = mapIdVersEtage.get(idQuiSeraCréé);
            mapIdVersEtage.put(idQuiSeraCréé,étageEcrasé); //met étageEcrasé sur son id originel
            mapIdVersEtage.put(idSouhaité,étageACréer); // met étageACréer sur le bon id.
            System.out.println("Changements fait. id devait être"+idSouhaité);
            System.out.println("it est maintenant"+mapEtage.get(étageACréer));
        }
 //A FINIR      A FINIR   A FINIR  A FINIR   A FINIR   A FINIR   A FINIR 
        
        
        
    
    }
    
    //TODO :  finir récupérerOuvertures()
    public static ArrayList<Ouverture> récupérerOuvertures(String listeTexteDesOuvertures, Mur murPropriétaire){
        ArrayList<Ouverture> listeARenvoyer = new ArrayList<>();
        System.out.println("récupération des ouvertures du mur " + murPropriétaire.getId());
        System.out.println("METHODE A FINIR !!!!!!!! ");
        System.out.println("il faut faire en sorte que l'ouverture d'un mur2 soit assoicée au mur1");

        
        //test de fonctionnement de replaceAll avec son regex
        String listetest = "test regex : liste_ouverture=[hello,goodbye]";
        System.out.println("original is "+listetest);
        listetest = listetest.replaceAll("liste_ouverture=\\[", "");
        listetest = listetest.replaceAll("\\]", "");
        System.out.println("result is"+ listetest);
        
        //listeTexteDesOuvertures
        //on doit enlever "liste_ouverture=[" et "]" du texte
        listeTexteDesOuvertures = listeTexteDesOuvertures.replaceAll("liste_ouverture=\\[", "");
        listeTexteDesOuvertures = listeTexteDesOuvertures.replaceAll("\\]", "");
        
        //on doit séparer la liste d'ouvertures en différentes ouvertures (spéarées par ",").
                System.out.println(listeTexteDesOuvertures);
        if (! listeTexteDesOuvertures.equals("")){ //si le mur A EFFECTIVEMENT des ouertures
            String[] ouvertures = listeTexteDesOuvertures.split(",");
            for (int i = 0;i<ouvertures.length;i++){
                ouvertures[i] = ouvertures[i].trim();//enlève les espaces potentiels en début en fin de l'ouverture
                //en effet, à l'impression de l'arraylist liste_ouverture, java rajouete un espace après les virgules ","
            }
            //System.out.println("point de contrôle n°1"); //pour contrôler le fonctionneemnt dans la console
            //Arrays.stream(ouvertures).forEach(ouv -> System.out.println(ouv)); //impression de la listes des ouvertures de ce mur

            
            //ensuite séparer les ouvertures avec split(";"), pour ensuiet assigner chaque attribut au bon endroit.
            for (int k = 0;k<ouvertures.length;k++){
                System.out.println("création de l'ouverture n°" + k+1);
                String[] uneOuverture = ouvertures[k].split(";");
                
                //création de l'objet Ouverture
                //"#Syntaxe : \"Ouverture;ori_x;ori_y;orientation(char);longueur;idDuMur1;idDuMur2 \""
                double ori_x = parseDouble(uneOuverture[1]);
                double ori_y = parseDouble(uneOuverture[2]);
                char orientation = uneOuverture[3].charAt(0); //charAt(index) est la meilluer méthode que j'ai trouvé pour convertir "oreintation" en char.
                double longueur = Double.parseDouble(uneOuverture[4]);
                int idDuMur1 = parseInt(uneOuverture[5]);
                int idDuMur2 = parseInt(uneOuverture[6]);
                if (longueur==0.90){
                    Porte porteACréerSurMur1 = new Porte(ori_x,ori_y,orientation,mapIdVersMur.get(idDuMur1));
                    //on ajoute cette ouverture dans la listeARenvoyer, qui sera elle fournie à murACréer.setListe_ouverture
                    listeARenvoyer.add(porteACréerSurMur1);                         //mur1 est le murPropriétaire
                    if (idDuMur2 != 9999){ //9999 est l'équivalent du "null" pour l'id du mur2. voir le toString() d'ouverture.
                        Porte porteACréerSurMur2 = new Porte(ori_x,ori_y,orientation,mapIdVersMur.get(idDuMur2));
                    }                                                             
                    ////////////////////////////////////////////TODO : 
                    //Problème : si on crée plus tard un mur et on luit assigne la même oubertue (c'est don mur2 de l'ouverture)
                    //alors ce programme créérait une nouvelle Ouverture au lieu d'assigner l'Ouverture existante au mur.
                    //idée de solution :  créer enfin un identifiant pour l'Ouverture, afin de comparer des objets, 
                    //trouver ces objetes dans une map...
                } else if (longueur == 1.20){
                    Fenêtre fenêtreACréerSurMur1 = new Fenêtre(ori_x,ori_y,orientation,mapIdVersMur.get(idDuMur1));
                    //on ajoute cette ouverture dans la listeARenvoyer, qui sera elle fournie à murACréer.setListe_ouverture
                    listeARenvoyer.add(fenêtreACréerSurMur1);
                    if (idDuMur2 != 9999){ //9999 est l'équivalent du "null" pour l'id du mur2. voir le toString() d'ouverture.
                        Fenêtre fenêtreACréerSurMur2 = new Fenêtre(ori_x,ori_y,orientation,mapIdVersMur.get(idDuMur2));
                    }
                }
            }
        }   
        return listeARenvoyer;
    }  /////////A FINIR     A FINIR       A FINIR     A FINIR      A FINIR     A FINIR      A FINIR 

//    TODO : la syntaxe de Mur a changé
    public static void récupérerUnMur(String[] murEnString){
        //au 07/05/24 : "#Syntaxe  : \"Mur;id;idDuCoinDebut;idDuCoinFin;idDeEtageDuMur;idDePièce1;idDePièce2;liste_ouverture\""
        int idSouhaité= parseInt(murEnString[1]);
        int idQuiSeraCréé = compteurMur;
        int idDuCoinDebut = parseInt(murEnString[2]);
        int idDuCoinFin = parseInt(murEnString[3]);
        int idDeEtageMur = parseInt(murEnString[4]);
        int idDePièce1 = parseInt(murEnString[5]);
        int idDePièce2 = parseInt(murEnString[6]);
        ArrayList<Ouverture> liste_ouverture;
        //////////////////////////récupérerOuvertutes n'est pas fini :
        //le programme n'assigne pas actuellement une même ouverture à deux murs, il crée deux ouvertures pareils...
        
        Mur murACréer = new Mur(mapIdVersCoin.get(idDuCoinDebut), mapIdVersCoin.get(idDuCoinFin),mapIdVersEtage.get(idDeEtageMur)); //crée un mur dont l'identifiant est compteurMur
        //Attention, il faut que les étages soient créés d'abord!!
        //LOG
        System.out.println("nouveau mur, id devrait être : "+idSouhaité);
        System.out.println("l'id est " + murACréer.getId());
        
        if (idQuiSeraCréé != idSouhaité){
            //en créant automatiquement son identifiant, murACréer a peut-être prit l'identifiant d'un autre Mur.
            //Cet autre Mur est murEcrasé, son identifiant était idQuiSeraCréé
            mapMur.replace(murACréer,idSouhaité); //on assigne à murACréer l'identifiant voulu
            //murEcrasé est toujours lié vers idQuiSeraCréé dans mapMur
            
            Mur murEcrasé = mapIdVersMur.get(idQuiSeraCréé);
            mapIdVersMur.put(idQuiSeraCréé,murEcrasé); //met murEcrasé sur son id originel
            mapIdVersMur.put(idSouhaité,murACréer); // met murACréer sur le bon id.
            System.out.println("Changements faits. id devait être"+idSouhaité);
            System.out.println("it est maintenant"+mapMur.get(murACréer));
        }
 //A FINIR      A FINIR   A FINIR  A FINIR   A FINIR   A FINIR   A FINIR 
        
        liste_ouverture = récupérerOuvertures(murEnString[7],murACréer);
        murACréer.setListe_ouverture(liste_ouverture);
        
        
    }
    //à répéter pour les autres
    
    //public static void récupérerUnePièce(String [] pièceEnString)
    
    //public static void récupérerUnAppartement(String [] appartementEnString){
    //ajouter cet appartement dans l'étage concerné avec appartementACréer.getEtage().addAppartement(appartementACréer)
    //}
    
    public static void récupérerLesDonnéesSauvegardées(String nom_fichier){
        ArrayList<String> data= Architecture_officielle.lectureGénérale(nom_fichier);
        //data est l'arraylist contenant chaque ligne
        System.out.println("nombre de ligne :" + data.size()); // Affichage du nombre de ligne dans le fichier text lu par le BufferedReader
        for (int k = 0; k < data.size(); k++) {      // Debut boucle utile pour la réalisation du stockage dans les listes
            String[] elements = data.get(k).split(";"); //Création d'un tableau pour chaque indice de 'data' avec chaque case du tableau un élèment se situant entre les ";"
            if ((! elements[0].startsWith("=")) && (! elements[0].startsWith("#"))){ 
            //si la ligne ne commence pas par "=" ("liste de...") ou "#" ("Syntaxe")
            switch (elements[0]) {
            //COINS
            //ETAGES
            //MURS
            //PIECES
            //APPARTEMENT
                case "Coin":
                    récupérerUnCoin(elements);
                    //création du coin décrit par la ligne elements : Coin;id,x;y .
                    break;
                case "Etage":
                    récupérerUnEtage(elements);
                    //A FINIR
                    break;
                case "Mur":
                    System.out.println("la récupération des murs n'est pas opérationnelle. il faut adapter la nouvelle syntaxe.");
                    for (int i = 8; i<elements.length;i++){
                        elements[7]=elements[7] + ";" + elements[i];
                        //le regex a en effet séparé les éléments des Ouvertures (split avec ";"), je les remet donc ensemble.
                    }
                    récupérerUnMur(elements);
                    //ATTENTION
                    //récupérerOuvertures ne fonctionne pas entièreemnt
                    //donc pour le moment, une ouverture ne peut avoir deux murs....
                    break;
                case "Pièce":
                    //récupérerUnePièce(elements);
                    break;
                case "Appartement":
                    //récupérerUneAppartement(elements);
                    break;
                default : 
                    break;
            }
                
            }
            
            
        }
        
    }